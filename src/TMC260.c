/**
 * @file TMC260.c
 * @author Andrew K. Walker
 * @date 14 JUN 2017
 * @brief Firmware for Trinamic TMC260-PA stepper motor driver.
 *
 * Set of low level functions for controlling the the Trinamic TMC260-PA stepper
 * motor driver.  Higher level functions...like commanding a particular motor
 * profile should be done in another layer.
 */

#include "TMC260.h"
#include "debug.h"

uint8_t TMC260_initialized = 0;
/* uint16_t TIM1_Period = 0; */

/* Public function.  Doxygen documentation is in the header file. */
void TMC260_initialize(void)
{

   TMC260_init_gpio();
   TMC260_initialized = 1;

}


/**
 *
 * @fn void TMC260_init_gpio(void)
 * @brief GPIO initialization for TMC260.
 * @param None
 * @return None
 *
 * - PA0  -> MOTOR_EN
 * - PA1  -> MOTOR_DIR
 * - PA2  -> MOTOR_STEP
 * - PC2  -> SG_260 (step guard...did we stall)
 * - PC13 -> CS_260 (chip select...the rest of SPI initialized elsewhere)
 *
 */
void TMC260_init_gpio(void)
{
   GPIO_InitTypeDef GPIO_InitStructure;
   EXTI_InitTypeDef EXTI_InitStructure;
   NVIC_InitTypeDef NVIC_InitStructure;

   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);


   GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2;
   GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
   GPIO_Init(GPIOA, &GPIO_InitStructure);

   GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
   GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
   GPIO_Init(GPIOC, &GPIO_InitStructure);

   /** @todo Make PC2 an EXTI so that we can easily catch and handle a stall condition. */
   GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
   GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
   GPIO_Init(GPIOC, &GPIO_InitStructure);

   SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOC, EXTI_PinSource2);

   EXTI_InitStructure.EXTI_Line = EXTI_Line2;
   EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
   EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   EXTI_Init(&EXTI_InitStructure);

   /** @todo Need to set the interrupt priority properly for stall guard. */
   NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;
   NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
   NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
   NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   NVIC_Init(&NVIC_InitStructure);

}

/**
 * @fn void EXTI2_Handler(void)
 * @brief Handles the external interrupt generated by the stall guard.
 *
 * @param None
 * @return None
 */
void EXTI2_IRQHandler(void)
{
   if(EXTI_GetITStatus(EXTI_Line2) != RESET)
   {
      /** @todo Need to actually implement stall guard functionality here. */
      debug_output_toggle(DEBUG_LED_RED);

      EXTI_ClearITPendingBit(EXTI_Line2);
   }
}


/**
 * @fn uint8_t TMC260_send_drvctrl_sdoff(uint8_t ph_a_dir, uint8_t ph_a_cur, uint8_t ph_b_dir, uint8_t ph_b_cur)
 * @brief Packs outgoing data and writes drvctrl reg when not using step/dir.
 *
 * @param
 * @return uint8_t TMC260 return status.
 */
uint8_t TMC260_send_drvctrl_sdoff(uint8_t ph_a_dir, uint8_t ph_a_cur, uint8_t ph_b_dir, uint8_t ph_b_cur)
{
   uint32_t regval;

   if((ph_a_dir > 1)||(ph_b_dir > 1))
   {
      return TMC260_ERROR_INVALID_INPUT;
   }

   regval = 0x00000000;
   regval |= (ph_a_dir << TMC260_DRVCTRL_SDOFF_PHA_DIR_SHIFT)&&TMC260_DRVCTRL_SDOFF_PHA_DIR_MASK;
   regval |= (ph_a_cur << TMC260_DRVCTRL_SDOFF_PHA_CUR_SHIFT)&&TMC260_DRVCTRL_SDOFF_PHA_CUR_MASK;
   regval |= (ph_b_dir << TMC260_DRVCTRL_SDOFF_PHB_DIR_SHIFT)&&TMC260_DRVCTRL_SDOFF_PHB_DIR_MASK;
   regval |= (ph_b_cur << TMC260_DRVCTRL_SDOFF_PHB_CUR_SHIFT)&&TMC260_DRVCTRL_SDOFF_PHB_CUR_MASK;

   /** @todo Call the spi send register value function here once it is set up! */

   return TMC260_SUCCESS;

}

